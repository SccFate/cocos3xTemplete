-- This file is generated by x-studio365 10.0.2101.0 Â© 2017, All rights reserved.
ui = {}

local function _extendNodeNameIndex(filename, root, node)
    local children = node:getChildren()
    for k, v in pairs(children) do
        local nodeName = v:getName()
        if nodeName ~= "" then
            if root[nodeName] ~= nil then
                print("warning duplicate node name in " .. filename, nodeName)
            end
            root[nodeName] = v
        end
        _extendNodeNameIndex(filename, root, v)
    end
end

function ui.createNode(filename, isPlayerTimeline)
    local node = cc.CSLoader:createNode(filename)
    if isPlayerTimeline then
        function node:play(frame, loop)
            local action = cc.CSLoader:createTimeline(filename)
            node:runAction(action)
            frame = frame or 0
            action:gotoFrameAndPlay(frame, loop)
            return action
        end
    end

    _extendNodeNameIndex(filename, node, node)
    return node  
end 

function ui.addTouchEndEvent(node, callback)
    node._touchCallbacks = { onEnded = callback }
    if node.setTouchEnabled ~= nil then
        node:setTouchEnabled(true)
    end
    node:addTouchEventListener(function(sender, eventType)
        if eventType == ccui.TouchEventType.began then
            doCallback(node._touchCallbacks.onBegan, node)
        elseif eventType == ccui.TouchEventType.ended then
            doCallback(node._touchCallbacks.onEnded, node)
        elseif eventType == ccui.TouchEventType.moved then
            doCallback(node._touchCallbacks.onMoved, node)
        else
            doCallback(node._touchCallbacks.onCanceled, node)
        end
    end)
    return node._touchCallbacks
end

--pressStyle:'color','scale'
function ui.setButton(target, callback, pressStyle)
    pressStyle = pressStyle or 'color'
    local event = ui.addTouchEndEvent(target, function(sender)
        doCallback(callback, sender)
        if pressStyle == 'color' then
            sender:setColor(hexColor(0xffffff))
        elseif pressStyle == 'scale' then
            sender:setScale(1)
        end
    end)
    event.onBegan = function(sender)
        if pressStyle == 'color' then
            sender:setColor(hexColor(0xeeeeee))
        elseif pressStyle == 'scale' then
            sender:setScale(0.9)
        end
    end
    event.onCanceled = function(sender)
        if pressStyle == 'color' then
            sender:setColor(hexColor(0xffffff))
        elseif pressStyle == 'scale' then
            sender:setScale(1)
        end
    end
end

function ui.onMouseClick(node, callback)
    local pDown
    ui.addMouseEvent(node, function(event)
        pDown = event:getLocationInView()
    end, nil, function(event)
        local scene = display.getRunningScene()
        local camera = scene:getDefaultCamera()
        local pUp = event:getLocationInView()
        local isHit = node:hitTest(pUp, camera)
        if isHit and pDown.x == pUp.x and pDown.y == pUp.y then
            doCallback(callback, node)
        end
    end)
end

function ui.addMouseEvent(node, onMouseDown, onMouseMove, onMouseUp, onCancelled)
    local listener = cc.EventListenerMouse:create()
    if onMouseDown then
        listener:registerScriptHandler(onMouseDown, cc.Handler.EVENT_MOUSE_DOWN)
    end

    if onMouseMove then
        listener:registerScriptHandler(onMouseMove, cc.Handler.EVENT_MOUSE_MOVE)
    end

    if onMouseUp then
        listener:registerScriptHandler(onMouseUp, cc.Handler.EVENT_MOUSE_UP)
    end

    local eventDispatcher = node:getEventDispatcher()
    eventDispatcher:addEventListenerWithSceneGraphPriority(listener, node)
    return listener
end

function ui.drag(target, boundSize, lockToCenter, callbacks)
    callbacks = callbacks or {}
    callbacks.allowAction = callbacks.allowAction or function() return true end
    local function limitMove(bounds)
        if target:getPositionX() < bounds.x then target:setPositionX(bounds.x) end
        if target:getPositionX() > bounds.x + bounds.width then
            target:setPositionX(bounds.x + bounds.width)
        end
        if target:getPositionY() < bounds.y then target:setPositionY(bounds.y) end
        if target:getPositionY() > bounds.y + bounds.height then
            target:setPositionY(bounds.y + bounds.height)
        end
    end

    local touchListener = target:addTouchEvent(function(touch)
        if not callbacks.allowAction() then return false end
        local rect = target:getBoundingBox()
        local touchPoint = target:getParent():convertToNodeSpace(touch:getLocation())
        if cc.rectContainsPoint(rect, touchPoint) then
            doCallback(callbacks.onBegan, target)
            --offset
            target._dragOffset = {}
            target._dragOffset.x = touchPoint.x - target:getPositionX()
            target._dragOffset.y = touchPoint.y - target:getPositionY()
            --bounds
            local gameSize = roomController:getGameSize()
            if boundSize then
                target._dragBounds = cc.rect(gameSize.width / 2 - boundSize.width / 2,
                    gameSize.height / 2 - boundSize.height / 2,
                    boundSize.width,
                    boundSize.height)
            end
            return true
        end
    end,
        function(touch)
            local touchPoint = target:getParent():convertToNodeSpace(touch:getLocation())
            if lockToCenter == true then
                target:move(touchPoint)
            else
                target:move(touchPoint.x - target._dragOffset.x, touchPoint.y - target._dragOffset.y)
            end
            if boundSize then limitMove(target._dragBounds) end
            doCallback(callbacks.onMoved, target)
        end,
        function(touch)
            doCallback(callbacks.onEnded, target)
        end,
        function()
            doCallback(callbacks.onCanceled, target)
        end)
    touchListener:setSwallowTouches(true)
    return callbacks
end
